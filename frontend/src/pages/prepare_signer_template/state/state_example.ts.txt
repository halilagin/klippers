import { MedClusterNode, MedClusterNodeBuilder, MedProject } from '../../../model/frontend'
import type  * as generated from '../../../model/generated/model'
import {v4 as uuidv4} from 'uuid'
import { create } from 'zustand'
import { BaseZustandState, ZustandUtils } from '../../../_zustand/Zustand'

export interface CreateClusterStore extends BaseZustandState {
  project: MedProject
  newWebSocketMessage:any | null
  webSocketMessageLog:string
  kubeInstallationStarted:boolean
  serializedProject:string

  setMock: (mock: string) => void
  setProjectName: (text: string) => void
  setClusterSshKeyName: (text: string) => void
  cloneNodeDefinition: (nodeId: string) => void
  deleteNodeDefinition: (nodeId: string) => void
  setNodeType: (nodeId: string, nodeType: string) => void
  getNodeType: (nodeId: string) => string
  setNodeCount: (nodeId: string, count: number) => void
  getNodeCount: (nodeId: string) => number
  setNodeDiskType: (nodeId: string, diskType: string) => void
  getNodeDiskType: (nodeId: string) => string
  setNodeRootDiskSize: (nodeId: string, diskSize: number) => void
  getNodeRootDiskSize: (nodeId: string) => number
  setNodeAdditionDiskSize: (nodeId: string, diskSize: number) => void
  getNodeAdditionDiskSize: (nodeId: string) => number
  serializeProject: () => void
  setCloudProviderName:(cloudProviderName: string) => void
  setCloudRegion:(region: string) => void
  setCloudUserKey:(key: string)  => void
  setCloudUserSecret:(secret: string)  => void
  setNewWebSocketMessage:(newMessage:any) => void
  clearWebSocketMessageLog: () => void
  startKubeInstallation: () => void
  setProject: (project:MedProject) => void
  updateNode: (node: MedClusterNode) => void
  
  // toSerializeJsonString:() => string
  // toJsonString:() => string
}


// redux -> zustand

export const cloneProject = (obj: MedProject): MedProject => Object.assign(Object.create(obj), obj)

//export const cloneNode = (obj: ClusterNode): ClusterNode => Object.assign(Object.create(obj), obj) as ClusterNode
export const cloneNode = (obj: generated.MedClusterNode): MedClusterNode => {return JSON.parse(JSON.stringify(obj)) as MedClusterNode}
export const cloneNodeById = (nodes: generated.MedClusterNode[], nodeId: string): MedClusterNode[] =>
  nodes.filter(n => n.id == nodeId).map(n => cloneNode(n))


export const ClusterDefinitionStoreActions = (set:any, get:any /** zustand set get */) => ({
  id: 'CreateClusterStore',
  newWebSocketMessage:null,
  project: new MedProject(),
  webSocketMessageLog:"",
  kubeInstallationStarted:false,
  serializedProject:"", 
  masterMasterIdx:0, 



  updateNode(node: MedClusterNode) {  
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster.serializedNodes = state.project.cluster.serializedNodes.map(n => {
        return n.id == node.id ? node : n
      })
    })
  },
  
  clearWebSocketMessageLog() {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.webSocketMessageLog = ""
    })
  },

  setProject(project: MedProject) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project = project
    })
  },
  setMock(mock:string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.mock = mock
    })
  },

  
  setNewWebSocketMessage(newMessage:string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.newWebSocketMessage = newMessage
      state.webSocketMessageLog = state.webSocketMessageLog+newMessage+"\n"
    })
  },
  
  startKubeInstallation() {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.kubeInstallationStarted = true
    })
  },
  getNodeAdditionDiskSize(nodeId: string): number {
    return get()
      .project.cluster.nodes.filter((n:any) => n.id == nodeId)
      .map((n:any) => n.root_additional_disk_size)[0]
  },
  setNodeAdditionDiskSize(nodeId: string, root_additional_disk_size: number) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster?.nodes
        .filter(n => n.id == nodeId)
        .map(n => (n.root_additional_disk_size = root_additional_disk_size))
    })
  },
  getNodeRootDiskSize(nodeId: string): number {
    return get()
      .project.cluster.nodes.filter((n:MedClusterNode)=> n.id == nodeId)
      .map((n:MedClusterNode) => n.root_disk_size)[0]
  },
  setNodeRootDiskSize(nodeId: string, root_disk_size: number) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster?.nodes.filter(n => n.id == nodeId).map(n => (n.root_disk_size = root_disk_size))
    })
  },

  getNodeDiskType(nodeId: string): string {
    return get()
      .project.cluster.nodes.filter((n:MedClusterNode) => n.id == nodeId)
      .map((n:MedClusterNode) => n.disk_type)[0]
  },

  setNodeDiskType(nodeId: string, diskType: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster?.nodes.filter(n => n.id == nodeId).map(n => (n.disk_type = diskType))
    })
  },

  getNodeCount(nodeId: string): number {
    return get()
      .project.cluster.nodes.filter((n:MedClusterNode) => n.id == nodeId)
      .map((n:MedClusterNode) => n.count)[0]
  },
  setNodeCount(nodeId: string, count: number) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster?.nodes.filter(n => n.id == nodeId).map(n => (n.count = count))
    })
  },

  getNodeType(nodeId: string): string {
    const idx = get().project.cluster.nodes.findIndex((n:MedClusterNode) => n.id == nodeId)
    return get().project.cluster.nodes[idx].node_type
  },
  setNodeType(nodeId: string, nodeType: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      const idx = state.project.cluster.nodes.findIndex(n => n.id == nodeId)
      state.project.cluster.nodes[idx].node_type = nodeType
    })
  },
  setProjectName(name: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.name = name
    })
  },

  setClusterSshKeyName(ssh_key_name: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster.ssh_key_name = ssh_key_name
    })
  },

  serializeProject() { //master:1, worker:3, etcd:1 -> master:1, worker:1, etcd:1, worker:1, worker:1
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      const nodes:MedClusterNode[] = [
        ...state.project.cluster.nodes.filter(node => node.count == 1).map(n => {
          n.id = uuidv4()
          n.tags = {"medflow_nodeid":n.id,"medflow_nodetype": n.node_type}
          return n    
        }),
        ...state.project.cluster.nodes
          .filter(node => node.count > 1)
          .flatMap(node => {
            let arr=[]
            for (let i=0;i<node.count;i++){
              let n = cloneNode(node)
              n.count=1
              n.id = uuidv4()
              n.tags = {"medflow_nodeid":n.id,"medflow_nodetype": n.node_type}
              arr.push(n)
            }
            return arr
          })
      ] as MedClusterNode[]

      state.project.cluster.serializedNodes = nodes
      const masterIdx = state.project.cluster.serializedNodes.findIndex(n => n.node_type == "Master")
      state.serializedProject = JSON.stringify(state.project,undefined, 2)
    })
  },

  cloneNodeDefinition(nodeId: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster.nodes = [
        ...state.project.cluster.nodes,
        ...cloneNodeById(state.project.cluster.nodes, nodeId).map(n => {
          n.id = uuidv4()
          return n
        })
      ]
    })
  },

  deleteNodeDefinition(nodeId: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.cluster.nodes = [...state.project.cluster.nodes.filter(n => n.id != nodeId)]
    })
  },


  setCloudUserKey(key: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.provider.key = key
    })
  },

  setCloudUserSecret(secret: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.provider.secret = secret
    })
  },

  setCloudProviderName(cloudProviderName: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.provider.name = cloudProviderName
    })
  },
  setCloudRegion(region: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      state.project.provider.region = region
    })
  },
  setStep(newStep: string) {
    ZustandUtils.setState(set, get, (state: CreateClusterStore) => {
      
    })
  },
})

export const useClusterDefinitionStore = create<CreateClusterStore>((set, get) => (ClusterDefinitionStoreActions(set, get)))

export default useClusterDefinitionStore


export interface KubeFlowInstallationStore extends BaseZustandState {
  plugins: string[]
  monitorable: boolean
  loggable: boolean
}



export const KubeFlowInstallationStoreActions = (set:any, get:any /** zustand set get */) => ({
  id: "kubeFlowInstallationStore",
  plugins: [],
  monitorable: false,
  loggable: false,

  setLoggable(loggable: boolean) {
    ZustandUtils.setState(set, get, (state: KubeFlowInstallationStore) => {
      state.loggable = loggable
    })
  },

  setMonitorable(monitorable: boolean) {
    ZustandUtils.setState(set, get, (state: KubeFlowInstallationStore) => {
      state.monitorable = monitorable
    })
  },

  setplugins(plugins: string[]) {
    ZustandUtils.setState(set, get, (state: KubeFlowInstallationStore) => {
      state.plugins = plugins
    })
  },
})

export const useDummyStore = create<KubeFlowInstallationStore>((set, get) => (KubeFlowInstallationStoreActions(set, get)))

